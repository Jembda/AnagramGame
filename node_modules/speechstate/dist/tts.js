"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ttsMachine = void 0;
const xstate_1 = require("xstate");
const getToken_1 = require("./getToken");
const TextToSpeech_1 = require("web-speech-cognitive-services/lib/SpeechServices/TextToSpeech");
const REGION = "northeurope";
exports.ttsMachine = (0, xstate_1.createMachine)({
    id: "tts",
    types: {},
    context: ({ input }) => ({
        ttsDefaultVoice: input.ttsDefaultVoice || "en-US-DavisNeural",
        audioContext: input.audioContext,
        azureCredentials: input.azureCredentials,
    }),
    initial: "GetToken",
    on: {
        READY: {
            target: ".Ready",
            actions: [
                (0, xstate_1.assign)({
                    wsaTTS: ({ event }) => event.value.wsaTTS,
                    wsaUtt: ({ event }) => event.value.wsaUtt,
                }),
                (0, xstate_1.sendParent)({ type: "TTS_READY" }),
            ],
        },
        ERROR: { actions: (0, xstate_1.sendParent)({ type: "TTS_ERROR" }) },
    },
    states: {
        Ready: {
            initial: "Idle",
            states: {
                Idle: {
                    on: {
                        SPEAK: {
                            target: "Speaking",
                            actions: (0, xstate_1.assign)({ agenda: ({ event }) => event.value }),
                        },
                    },
                },
                Speaking: {
                    initial: "Go",
                    on: {
                        STOP: {
                            target: "Idle",
                        },
                        TTS_STARTED: {
                            actions: (0, xstate_1.sendParent)({ type: "TTS_STARTED" }),
                        },
                        SPEAK_COMPLETE: {
                            target: "Idle",
                        },
                    },
                    exit: (0, xstate_1.sendParent)({ type: "SPEAK_COMPLETE" }),
                    states: {
                        Go: {
                            invoke: {
                                src: "start",
                                input: ({ context }) => ({
                                    wsaTTS: context.wsaTTS,
                                    wsaUtt: context.wsaUtt,
                                    ttsLexicon: context.ttsLexicon,
                                    voice: context.agenda.voice || context.ttsDefaultVoice,
                                    // streamURL: context.agenda.streamURL,
                                    utterance: context.agenda.utterance,
                                }),
                            },
                            on: {
                                CONTROL: "Paused",
                            },
                            exit: "ttsStop",
                        },
                        Paused: {
                            on: {
                                CONTROL: "Go",
                            },
                        },
                    },
                },
            },
        },
        Fail: {},
        GetToken: {
            invoke: {
                id: "getAuthorizationToken",
                input: ({ context }) => ({
                    credentials: context.azureCredentials,
                }),
                src: "getToken",
                onDone: {
                    target: "Ponyfill",
                    actions: [
                        (0, xstate_1.assign)(({ event }) => {
                            return { azureAuthorizationToken: event.output };
                        }),
                    ],
                },
                onError: {
                    actions: ({ event }) => console.error("[TTS] getToken error", event),
                    target: "Fail",
                },
            },
        },
        Ponyfill: {
            invoke: {
                id: "ponyTTS",
                src: "ponyfill",
                input: ({ context }) => ({
                    audioContext: context.audioContext,
                    azureAuthorizationToken: context.azureAuthorizationToken,
                }),
            },
        },
    },
}, {
    actions: {
        ttsStop: ({ context }) => {
            context.wsaTTS.cancel();
        },
    },
    actors: {
        getToken: getToken_1.getToken,
        ponyfill: (0, xstate_1.fromCallback)(({ sendBack, input }) => {
            const ponyfill = (0, TextToSpeech_1.default)({
                audioContext: input.audioContext,
                credentials: {
                    region: REGION,
                    authorizationToken: input.azureAuthorizationToken,
                },
            });
            const { speechSynthesis, SpeechSynthesisUtterance } = ponyfill;
            const tts = speechSynthesis;
            const ttsUtterance = SpeechSynthesisUtterance;
            tts.addEventListener("voiceschanged", () => {
                const voices = tts.getVoices();
                if (voices.length > 0) {
                    console.debug("[TTS] READY");
                    sendBack({
                        type: "READY",
                        value: { wsaTTS: tts, wsaUtt: ttsUtterance },
                    });
                }
                else {
                    console.error("[TTS] No voices available");
                    sendBack({ type: "ERROR" });
                }
            });
        }),
        start: (0, xstate_1.fromCallback)(({ sendBack, input }) => {
            if (["", " "].includes(input.utterance)) {
                console.debug("[TTS] SPEAK: ", input.utterance);
                input.wsaTTS.speak("");
            }
            else {
                console.debug("[TTS] SPEAK: ", input.utterance);
                const content = wrapSSML(input.utterance, input.voice, input.ttsLexicon, 1); // todo speech rate;
                const utterance = new input.wsaUtt(content);
                utterance.addEventListener("start", () => {
                    sendBack({ type: "TTS_STARTED" });
                    console.debug("[TTS] TTS_STARTED");
                });
                utterance.addEventListener("end", () => {
                    sendBack({ type: "SPEAK_COMPLETE" });
                    console.debug("[TTS] SPEAK_COMPLETE");
                });
                input.wsaTTS.speak(utterance);
            }
        }),
    },
});
const wrapSSML = (text, voice, lexicon, speechRate) => {
    let content = `<speak version="1.0" xmlns="http://www.w3.org/2001/10/synthesis" xmlns:mstts="http://www.w3.org/2001/mstts" xml:lang="en-US"><voice name="${voice}">`;
    if (lexicon) {
        content = content + `<lexicon uri="${lexicon}"/>`;
    }
    content =
        content +
            `<prosody rate="${speechRate}">` +
            `${text}</prosody></voice></speak>`;
    return content;
};
